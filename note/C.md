# C语言笔记

## Chapter 0 起源

> C语言主要是由贝尔电话实验室的丹尼斯·M·里奇（Dennis M.Ritchie）开发的，从1969年开始设计并于1973年开发完成。……它是一种早期的程序设计语言B语言的后继者。B是BCPL（Basic CPL）语言的一种精简版本，而BCPL来源于CPL（Combined Programming Language）。
>
> 参见[《编码》](../books/history/《编码：隐匿在计算机软硬件背后的语言》.md)396页

[cppreference]: http://en.cppreference.com/w/

## Chapter 1 基本概念

源文件拓展名`.h`, `.c`

源文件需要经过编译器编译和链接成为可执行文件

Windows上有`msys2`项目提供的`gcc`以及微软的`MSVC`编译器`cl`

### main() 函数

推荐使用`int main(void){ ... }`形式的main()函数：

- `void main(){}` 不符合C语言标准。
- `main(){}` 不符合C99标准。
- `int main(){}` 能编译运行，但它不是标准的C语言形式。

参见[CPP Reference网站中关于main()函数的内容](http://en.cppreference.com/w/c/language/main_function)。

### 标识符（biāo zhì fú）

C语言的标识符（identifier）可使用小写字母、大写字母、下划线和数字，不能以数字开头，以避免与数值常量混用。

推荐使用字母作为变量名的开头，把下划线留给标准库使用。

### 关键字

如果一个字符序列不能用作标识符，那么它是一个关键字（keyword）。
如果一个字符序列不应当用作标识符，那么他是一个保留标识符（reserved identifier）。

从这个角度看，main和function都不是C语言的合理标识符，`int`和`char`是C语言的关键字。

## Chapter 2 数据类型

### 位、字节与字

位（bit）是逻辑上和物理上容纳数据的最小单位，一个位可以容纳0，1中的一个值。

字节（byte）是计算机储存数据的常用单位，一个字节*总是*等于8位。
在C语言中，有时候“字节”用来指称能容纳平台基本字符集中的一个字符的储存单位。

字（word）是自然的储存单位。Windows操作系统的字长通常为32位或64位（就是常说的“32位操作系统”或“64位操作系统”）。

### 常量书写

| 字面值 | 数据类型 | 备注 |
| --- | --- | --- |
| 32 | int | |
| 32L | long | |
| 32LL | long long | |
| 32U | unsigned int | |
| 32UL | unsigned long | |
| 32ULL | unsigned long long | |

对于整数类型，只有在硬编码（hard code）数值时的一些特殊情况下才需要字面值后缀。
一个例子是在C语言中嵌入汇编代码时，使用32ULL指示一个64位的内存地址。

对于下面的例子，有无后缀均可：

```c
long a = 32;
long b = 32L;

printf("%ld %ld", a, b);    // 输出 32 32

```

| 字面值 | 数据类型 | 备注 |
| --- | --- | --- |
| 32.64 | double | |
| .32 或 0.32 | double | |
| 3.2E3 或 3.2e3| double | = 3.2 * 10³ |
|32. | double | 默认情况下浮点数字面值总是被当作double类型 |
|32.F | float | 只有使用F后缀的字面值才被当作float类型 |
| 0xA.1FP10 | double | 十六进制浮点数，十进制值为 `(10 * 16⁰ + 1 * 16⁻¹ + 15 * 16⁻² ) * 2¹⁰` |

对于浮点数，无后缀字面值总是被认定为double或更高精度的类型。要对float变量赋值，建议使用F后缀。

没有八进制浮点数。

### 进位制与整型字面值

十六进制中的A，B，C，D，E和F分别代表十进制中的10，11，12，13，14和15。

| 进位制 | 前缀 | 例子 |
| --- | --- | --- |
| 十进制（**DEC**imal） | N.A. | 12 |
| 八进制（**OCT**al） | 0 | 014，等于十进制数12 |
| 十六机制（**HEX**adecimal） | 0x 或 0X | 0xC，等于十进制数12 |

### 字符字面值

char本质上是一个占用一个或多个字节来储存信息的形式。
如果对char类型赋值，赋值操作符右边的操作数实际上会转变成整型赋给char类型的变量。

```c
char ch = <右操作数>;

// 向屏幕输出
printf("%c", ch);

```

| “右操作数”形式 | “右操作数”类型 | 屏幕上输出的字符（在兼容Ascii的环境中） |
| --- | --- | --- |
| 'c' | 字符字面值 | c |
| '\n' | 转义字符 | （换行） |
| '\0143' 或 '\143' | 转义字符，格式为“\0ooo”或"\ooo"，其中“ooo”为八进制数 | c |
| '\x63' 或 '\0x63' | 转义字符，格式为“\xhh”，其中“hh”为十六进制数 | c |
| 99, 0143 或 0x63 | 整型数值 | c |

### *sizeof()*

*sizeof()* 以字节为单位给出类型的大小，使用 *printf()* 打印 *sizeof()* 运算结果时，可以使用“%zd”或“%zx”等说明符。

对标识符或者字面值使用 *sizeof* 时，可以省略圆括号；对于能使用 *sizeof* 查看占用储存空间大小的关键字（如，类型名float）则不能省略圆括号。总是使用圆括号是一个好习惯。

*sizeof()*的返回值是一个*size_t*类型，它可能是unsigned int或unsigned long的同义词。

```c
printf("Long类型的占用%zd字节。", sizeof(long));

```

## Chapter 3 字符串和格式化输入/输出

### 字符串类型

字符串以空字符（'\0'）结束。在使用 *scanf()* 读取字符串以及使用字符串字面值，以及使用*printf()*打印字符串时，空字符会被自动处理。

### *printf()* 格式说明符

组合格式说明符时，首先是“+”“-”等通用打印格式说明符，然后指定宽度和精度，（对于整型）接着是整型类型和整形进位制，（对于浮点型）或者是浮点数打印形式，或者是其他类型。

用整数来指定宽度；用小数点“.”开头，后接整数的方式指定精度。宽度为打印时最小字段宽度；精度对于小数打印为小数点右边的数字位数，对于科学计数法是指有效数字的最大位数，对于字符串是指打印字符的最大数目，对于整型是指打印数字的最小位数（如有必要，会用前导零填充）。只使用“.”而后不附加整数，则等价于“.0”，即“%.f”与“%.0f”相同，均不输出小数。

也可以使用程序中的整型或浮点型变量的值来指定宽度，这种情况下使用*修饰符。

| 通用打印形式 | 符号 | 备注 |
| --- | --- | --- |
| 左对齐 | - | *printf()* 指定宽度打印时默认右对齐 |
| 强调符号 | + | 非负时显示正号，负值时显示负号 |
| 保证符号位 | （空格） | 非负时显示前导空格，负值时显示负号 |
| 显示进制前缀 / 保证尾随零 | # | （对于整型）根据进制，可对应“0”、“0x”和“0X”前缀 （对于浮点型）保证至少有一位小数点 |
| 用前导零填充打印宽度 | 0 | |

| 整型类型 | 符号 | 备注 |
| --- | --- | --- |
| short | h | |
| int | N.A. | |
| long | l | |
| long long | ll | |

| 整型打印形式 | 符号 | 备注 |
| --- | --- | --- |
| 有符号十进制 | d 或 i | |
| 无符号十进制 | u | |
| 无符号八进制 | o | |
| 无符号十六进制 | x | 不是“h”，“h”用于表示short类型 |

| 浮点数类型 | 符号 | 备注 |
| --- | --- | --- |
| float | N.A. | |
| double | l | |
| long double | L | |

| 浮点数打印形式 | 符号 | 备注 |
| --- | --- | --- |
| 小数形式的浮点数 | f | |
| 指数计数法的浮点数 | e 或 E | |
| 指数计数的十六进制浮点数 | a 或 A | |
| 自动选择计数法 | g 或 G | 根据浮点数值的不同自动选择计数法，科学记数法在指数小于4或数值大于等于精度时使用 |

| 其他类型 | 符号 | 备注 |
| --- | --- | --- |
| char | c | 打印一个字符 |
| 百分号 | % | 打印一个百分号 |
| 字符串 | s | 打印字符串 |
| 指针 | p | 打印指针 |
| --- | --- | --- |
| 与整型结合的char | hh | 与整型说明符一起使用，表示signed char（"%hhd"）或unsigned char（"%hhu"） |
| 指针的差 | t | 与整型说明符一起使用，如“td” |
| *sizeof* 返回值（size_t类型） | z | 与整型说明符一起使用，如“zd” |

严谨地讲，格式说明符分为转换说明符和转换说明修饰符。转换说明修饰符可用于修饰转换说明符，修饰符不能独立充当说明符。上表的“整型打印形式”、“浮点数打印形式”以及“其他类型”的上半部分是说明符，“通用打印形式”、“整型类型”、“浮点数类型”以及“其他类型”的下半部分是修饰符。

### *scanf()* 格式说明符

| 读取整型 | 符号 | 备注 |
| --- | --- | --- |
| 有符号十进制 | d 或 i | |
| 无符号十进制 | u |
| 有符号八进制 | o | |
| 有符号十六进制 | x 或 X | |
| --- | --- | --- |
| int | N.A. | |
| long | l | |
| long long | ll |

| 读取浮点数 | 符号 | 备注 |
| --- | --- | --- |
| 小数形式浮点数 | f | |
| 指数计数法形式浮点数 | e 或 E | |
| 指数计数法形式的十六进制浮点数 | a 或 A | |
| 自动判断浮点数形式 | g 或 G |
| --- | --- | --- |
| float | N.A. | |
| double | l | |
| long double | L |

| 读取其他类型 | 符号 | 备注 |
| --- | --- | --- |
| 字符 | c | |
| 字符串 | s | |
| 指针 | p | |

| 转换修饰符 | 意义 |
| --- | --- |
| * | 滞后赋值 |
| 使用整数指定最大读取宽度 | 在达到最大宽度时或遇到第一个空白字符时停止读取 |
| hh | 把整数读取成signed char（"%hhd"）或unsigned char（"%hhu"）|

与 *printf()* 格式说明符类似，*scanf()* 格式说明符分为“转换说明符”和“转换说明修饰符”。上表中，“读取整型”的前半部分、“读取浮点数”的前半部分和“读取其他类型”为转换说明符，“读取整型”后半部分、“读取浮点型”后半部分、“转换修饰符”部分为转换修饰符。

格式字符串中的空格表示跳过下一个输入项之前任何空格。因此 `scanf("%c", &ch);` 表示读取下一个字符，而 `scanf(" %c", &ch);` 表示读取下一个非空白字符。

### *printf()* 和 *scanf()*

#### 返回值

*printf()* 的返回值返回打印字符的个数；

*scanf()* 的返回值返回成功读取项目的个数，或在遇到“文件结尾”时返回EOF。

#### 格式字符串中的*修饰符

在 *printf()* 的格式字符串中使用`*`修饰符，表示打印宽度和精度有程序中整型或浮点型的变量来指定。

在 *scanf()* 的格式字符串中使用`*`修饰符时，将`*`放在%与说明符之间，表示滞后赋值。

### 整型和浮点型数大小限制

在 *limits.h* 和 *float.h* 头文件中定义了有关整型和浮点型数大小限制的信息。

## Chapter 4 运算符、表达式和语句

### 基本运算符

赋值运算符、加减乘除运算符，自增、自减运算符。

C中没有幂运算符。

### 除法与模运算

整型的除法总是截尾，并且是*趋零截尾*。

因此，正数的模是正数，负数的模是负数。

### 优先度

共享操作数的操作符，执行顺序按优先度决定；不共享操作数的操作符，即使具有同等的优先度，也不能获知哪一个运算先执行。如`7*6 + 8*9`，不知道`7*6`先执行还是`8*9`先执行。

### 表达式和语句

表达式（expression）由运算符和操作数组成，每个表达式都有值。一些表达式是其他表达式的组成部分，称为子表达式（subexpression）。

一个（有作用的）语句（statement）是一条完整的计算机指令，语句用结束处的分号标识。C把结束处有分号的表达式看作语句，称为*表达式语句*。

声明语句（declaration statement）不是一个表达式语句，它没有值。

赋值语句（assignment statement）是表达式语句的一个特例。

函数语句（function statement）引起函数的执行。

结构化语句（structrued statement）是比一般语句复杂的语句。

复合语句（compound statement）或代码块（block）

空语句是什么也不做的语句。

#### 副作用和顺序点

从C的角度看，C的主要目的是为表达式求值。表达式引起的数据对象的变化、文件的修改等称为副作用（side effect）。

顺序点（sequence point）是程序执行中的一点，在该点处，所有的副作用都在进入下一步前被计算。在C中，语句的分号、一些运算符、任何完整的表达式（不是子表达式的表达式）的结束标志了顺序点。

### 类型转换

自动类型转换的规则如下：

- 在表达式里，char和short类型自动转换为int，需要时转换为unsigned int。
- 在传递给`printf("%f")`时，float自动转换为double。
- 在包含两种数据类型的运算中，两个值被转换成两种类型里较高级的类型。
- 在赋值语句中，计算的最后结果被转换成被赋值的变量的类型（可能导致降级）。

可以通过指派运算符强制转型。

### 自增/自减操作符

由于不能保证在语句执行过程中何时自增，在下列情况不要使用自增/自减运算符：

- 变量多次出现在同一个表达式里
- 变量出现在同一个函数的多个参数中

## Chapter 5 控制语句：循环

每次循环都被称为一次*迭代*。

### 关系运算符

大于（>）、小于（<）、大于或等于（>=）、小于或等于（<=）、等于（==）和不等于（!=）。

不能使用关系运算符比较字符串。

只能使用“>”或“<”来比较浮点数。

如果关系表达式为真，值为1；反之，值为0。

如果比较的双方有一方是常量，可以把常量放在左边，有助于发现错误。`5 == canoes`

### 逻辑真与假

非零为真，零为假。

### 逗号运算符

逗号运算符“,”标志了一个顺序点，保证被它分开的表达式从左到右计算。逗号表达式的值是右边成员的值。

逗号“,”也被用作分隔符。

### while循环

`while (expression) statement;`

*statement*部分既可以是带有分号的简单语句，也可以是使用花括号包围的一个复杂语句，也可以是一条空语句。

只有*expresion*为真，*statement*才会执行。

空语句示例：

```c
while( scanf("%d", &num) == 1 )
    /* 跳过整数输入 */
;

```

### for循环

`for(ctrl_1; ctrl_2; ctrl_3) statement;`

控制表达式1在循环开始前执行；控制表达式2为真时开始一次迭代；控制表达式3在一次迭代完成后执行。

### do while循环

`do statement while(expression);`

### 循环辅助手段

- *continue* 循环的其余部分被忽略，开始下一次循环；对于for循环，从控制段的更新部分开始；对于while循环，从判断循环表达式开始。
- *break* 跳出一层循环；对于for循环，不执行控制段的更新部分。

## Chapter 6 分支和跳转

学习内容提要：

- 关键字：*if、else、switch、continue、break、case、default、goto*
- 运算符：*&&* *||* *?:*
- 函数：*getchar()*、*putchar*以及*ctype.h*系列
- 怎样使用if和if else语句以及如何嵌套使用它们
- 使用逻辑运算符将关系表达式组合为更加复杂的判断表达式。
- C的条件运算符。
- switch语句。
- break、continue和goto跳转。
- 使用C的字符I/O函数：getchar()和putchar()。
- 由ctype.h头文件提供的字符分析函数系列。

### `if... else...`

`if(epression) statement`

`if(expression) statement1 else statement2`

`if(expression1) staement1 else if(expression2) statement2 else statement3`

### 与、或、非

- && 与
- || 或
- ! 非

可以使用iso646.h改变拼写逻辑运算符的方法：

- and 与
- or 或
- not 非

关系运算符优先级高于逻辑运算符。非运算符的优先级高于与运算符，或运算符优先级最低。与运算符和或运算符标志一个顺序点。

### 条件运算符 `?`

`expression 1 ? expression2 : expression3`

### 多重选择 switch

```cpp

switch(integer expression)
{
    case constant1:
        statements
        break;
    case constant2:
        statements
        break;
    default:
        statements
}

```

case标签必须为整型。如果没有break标签，匹配标签之后的语句都会被执行，直到遇到break标签或switch结构结束。

### goto

`label: statement`

`goto label;`

## Chapter 7 字符输入/输出和输入确认

### 缓冲区

缓冲分两种：完全缓冲（fully buffered）I/O和行缓冲（line-buffered）I/O。完全缓冲在缓冲区满时被清空，行缓冲在遇到换行符时清空。

### EOF

在Windows上模拟：Ctrl + Z

在Linux上模拟：Ctrl + D

### 操作系统重定向输入

- `命令 < 输入流 > 输出流`
- `命令 >> 输出流` 往现有文件末尾追加数据
- `前一个命令 | 后一个命令` 将前一个命令的输出作为后一个命令的输入

### 良好用户界面

使用单字符IO工具

```c
while((ch = getchar()) != 'q'){
    putchar(ch);
}

```

剔除错误的输入

```c
int input;
char ch;
while(scanf("%d", &input) != 1)
{
    while((ch = getchar)!='\n'){
        putchar(ch); // 剔除错误的输入
    }
    printf(" is not an integer.\n");
}

```

要创建良好的用户界面，需要注意 *scanf()* 总是将空白输入留在输入流中，在遇到EOF时，函数返回EOF，而且不改变参数的值；*getchar()* 在遇到EOF时返回EOF。

## Chapter 8 函数

学习内容提要：

- 关键字：*return*
- 运算符：*\*（一元）* *&（一元）*
- 函数及其定义方式。
- 参数和返回值的使用方法。
- 使用指针变量作为函数参数。
- 函数类型。
- ANSI C原型。
- 递归。

### 函数原型

`retrun-type function-name(arguments-list);`

函数原型中函数的参数可以省略变量名。

### 形式参数与实际参数

函数定义中头部的参数是形式参数，函数调用时使用的参数是实际参数。实参复制给形参。实参与形参相互独立。

### 函数声明

函数可以在全局声明也可以在函数中声明。在函数中声明的函数在全局有效。函数在调用前需要先声明。

函数可以声明为无参数或不确定参数。

### 递归

函数可以递归调用。在return语句之前的递归称为尾递归。

## Chapter 9 数组和指针

学习内容提要：

- 关键字：*static*
- 运算符：*&\*（一元）*
- 创建与初始化数组的方法。
- 指针（基于已学的基础知识）及指针和数组间的关系。
- 编写使用数组的函数。
- 二维数组。

### 数组

声明和初始化：

`type identifer[N] = {elem1, elem2, ..., elemN};`

`N`可被省略，编译器将根据指定元素的个数初始化数组；部分初始化数组，数组其余元素会被自动初始化为0。

使用`{[1]=elem1, ..., elemN}`语法来指定初始化。如果指定初始化元素后有更多元素，则它们被用于后续数组元素的初始化。如果多次对一个元素初始化，最后一次有效。

使用花括号对数组初始化的语法仅在数组声明时有效。不能将数组作为一个整体进行赋值。

#### 多维数组

`type identifier[X][Y];`

*identifier* 是一个由x个元素组成的数组，而它的每一个元素是y个type类型元素组成的数组。

可以使用花括号语法声明和初始化数组：

```c
type identifier[X][Y] = {
    {elem11, elem12, elem13, ..., elem1y},
    {elem21, elem22, elem23, ..., elem2y},
    ...,
    {elemx1, elemx2, elemx3, ..., elemxy}
}
```

使用花括号声明时也可以去掉内部的花括号，前面的元素优先得到赋值。

使用指针操作多维数组，复杂度随数组维数的增加而增加。地址的地址和指针的指针是双重间接（double indirection）的一个典型例子。

区分指针的数组和数组的指针。`int * ptr[2]`是有两个int类型指针的数组而`int (* ptr) [2]`是指向一个拥有两个int类型数据的数组的指针。方括号的结合性高于*（可以借助“靠近标识符的先结合”来判断类型）。

`ptr[2]` 是一个含有两个元素的数组 → `* ptr[2]` 是一个含有两个元素的数组，数组的元素是指针 → `int * ptr[2]` 是一个含有两个元素的数组，数组的元素是指向int类型数据的指针；

`(* ptr)` 是一个指针 → `(* ptr) [2]` 是一个指针，指向拥有两个元素的数组 → `int (* ptr) [2]` 是一个指针，指向拥有两个int类型元素的数组。

#### 声明数组参数

在声明形参时，可以使用`int ar[]`代替`int * ar`。使用这样的形式可以提示 *ar* 是指向int数组中一个元素的指针。无论怎样声明，处理数组的函数实际上是使用指针作为形式参数的。

如果不希望改变数组内容，可以用*const*修饰形参中的指向数组的指针。

声明处理多维数组的函数的形式参数，可以使用`int (* ptr) [n][x][y]`和它的等价形式`int ptr[][x][y]`（第一个方括号留空表示它是指针，如果第一个方括号没有留空，效果上等价于留空的）。

#### 变长数组（VLA）

变长数组必须是自动储存类的（也就必须在函数内部或者），不能在初始化时进行声明。

声明处理变长数组的函数，变长数组参量需要在数组之前声明。如`int sum2d(int rows, int cols, int ar[rows][cols]);`，可以省略一般形参的名称和变长数组的维数，如`int sum2d(int, int, int ar[*][*]);`

### 指针

地址运算符 &

间接运算符 *

`ptr = &bah; val = * ptr;` 等价于 `val = bah;`

使用 `type * identifier;` 来声明指针。

不要对未初始化的指针取值。

自增运算符与间接运算符存在微妙的优先级关系，试区分`*ptr++`、`*++ptr`、`*(ptr++)`、`*(++ptr)`和`(*ptr)++`。其中`*ptr++`等价于`*(ptr++)`。

使指针自增1，指针指向下一个储存单元（而不是下一个字节）。

如果指针被*const*修饰，那么指针指向的数据不应该被改变。不能把*const*指针赋给非*const*指针（这样指针指向的数据可能会改变），但可以把非*const*指针赋给*const*指针，前提是只进行一层间接运算（即被赋值的*const*指针不能是指针的指针）。

下面的例子演示了如果忽略上述前提，在双重间接的情况下*const*内容被修改的例子：

```c
const int ** pp;
int * p;
const int n = 10;

pp = &p;    // 不允许
*pp = &n;   // 使p指向n
*p = 11;    // n被修改
```

#### 基本操作

- **赋值（Assignment）** 将地址赋给指针，可以使用地址运算符或数组名。还可以使用类型指派来为不兼容的指针赋值。
- **求值（value-finding）或取值(derefering)** 使用间接运算符。
- **取指针地址** 使用地址运算符。
- **指针的整数加法和减法**
- **求差值（differencing）** 差值的单位是相应类型的大小，而不是字节。有效差值运算的前提是两个指针指向同一个数组
- **比较** 可以使用关系运算符比较两个相同类型的指针。

一个指针不能另一个指针相加或相乘。

#### 指针与数组

在表达式中使用数组名，等同于使用该数组首元素的地址，即数组名是指向首元素的（只读）指针。

指针变量和数组标识符都可以使用方括号语法和指针语法：`ar[n]`等价于`*(ar + n)`。区别在于，指针可以通过自增自减运算符（如`ar++`）来修改指向的地址，而数组名虽是指针，却是指向数组首元素的只读指针，不能被修改，即`ar++`是无效的。

### 复合文字

复合文字（Compound literal）是表示数组和结构内容的字面值。它没有标识符。

```c
(int [2]){1, 2}
```

上面的表达式创建了一个含有2个int元素的数组。表达式的值是指向数组首元素的指针。

可以省略元素的个数：

```c
(int []){1, 2, 3}
```

也适用于多维数组，但只能省略第一个维度。

```c
(int [][4]){{1, 2, 3, 4}, {5, 6, 7, 8}}
```

可以使用复合文字初始化一个指针，或者使用复合文字作为实际参数传递给参量形式匹配的函数。

## Chapter 10 字符串和字符串函数

> 绝大多数程序员认为这很搞笑，但仅限于这出现在别人的程序中时。

不要使用指针来改变一个已经用字面值初始化的字符串。如果有两个字符串字面值相同，则它在内存中的位置可能相同，用指针改变一个可能导致改变另一个。字符串属于静态储存类。

| 字符串函数 | 用法 |
| --- | --- |
| gets(char *) | 读取字符串直到遇到换行符，丢弃换行符，添加空字符 |
| fgets(char *, int n, stdin) | 读取字符串直到遇到换行符或读取完 **(n-1)** 个字符，n指定 **数组最大可容纳的字符数（包括空字符在内）**而不是最大可读取的字符数，保留换行符，添加空字符 |
| puts(char *) | 输出字符串，添加换行符 |
| fputs(char *, stdout) | 输出字符串，不添加换行符 |
| `<string.h>` | --- |
| strlen(char *) | 字符串长度 |
| strcat(char *, const char *) | 将第二个字符串链接到第一个字符串后面，返回值是第一个字符串 |
| strncat(char *, const char *, int) | 连接字符串，指定最大可添加的字符数（注意为空字符保留位置） |
| strcmp(char *, char *) | 按机器编码顺序比较字符串 |
| strncmp(char *, char *, int) | 限制搜索的范围 |
| strcpy(char *, char *) | 将第二个字符串复制到第一个字符串的位置，返回值是第一个字符串 |
| strncpy(char *, char *, int) | 指定最大可复制的字符数（注意为空字符保留位置），最终结果“充盈”n个字符 |
| --- | --- |
| sprintf(char *, 其余参数与printf相同) | 格式化字符串并输出到指定位置 |
| --- | --- |
| strchr(char * s, int c) | 返回指向在s中存放字符c的第一个位置的指针，未找到则返回空指针 |
| strpbrk(char *, char *) | 返回指向在第一个字符串中存放第二个字符串任意一个字符的位置的指针，未找到则返回空指针 |
| strrchr(char *, int c) | 返回指向字符最后一次出现在字符串中的位置的指针 |
| strstr(char *, char *) | 返回第一个字符串中第一次出现第二个字符串的位置 |
| `<stdlib.h>` | --- |
| atoi(char *)| Alphanumeric to integer，将字符串转换为整数并返回 |
| atol, atof等 | 返回long、float类型 |
| strtol, strtoul, strtod | 可以报告第一个不是数字的字符的位置 |
| ftoa, itoa等 | 不是标准函数 |

## Chapter 11 储存类、链接和内存管理

学习内容提要：

- 关键字：*auto external static register const volatile restricted*
- 函数：*rand() srand() time() malloc() calloc() free()*
- 在C中如何确定变量的作用域（它在多大范围内可知）以及变量的生存周期（它存在多长时间）。
- 设计更复杂的程序。

### 作用域

- 代码块作用域
- 函数原型作用域（如VLA）
- 函数作用域（仅适用于goto语句使用的标签）
- 文件作用域（全局变量）

### 链接

- 外部链接
- 内部链接（在外部定义中使用了储存类说明符static）
- 空连接

### 储存时期

- 静态储存时期
- 动态储存时期

自动变量不会被自动初始化。外部变量只能使用常量表达式来初始化。（只要类型不是一个数组，sizeof()就是一个常量表达式）

使用 *register* 关键字声明寄存器变量。

如果变量在其他文件声明，必须使用 *extern* 关键字来声明。

### *malloc()* 和 *free()*

`double * ptr = (double *)malloc(n * sizeof(double));` 成功分配内存则返回一个指向第一个分配内存空间的指针，否则返回空指针。应当显式地进行类型指派。

`free(ptr);` 释放占用的内存空间

*malloc()* 的等价语句是 *calloc()* 。

`double * ptr =  (double *)calloc(n, sizeof(double));` 返回值与 *malloc()* 相似。

### 类型限定词

#### volatile

当变量除了被程序改变之外还可能被其他代理改变时。一个变量可以同时是 *const* 和 *volatile* 。

#### restrict

只用于指针，表示该指针是访问数据块的唯一方式。

在函数原型中，参数的 *restrict* 要求保证指针是它指向的内容的唯一的访问方式。 `void * memcpy(void * restrict s1, const void * restrict s2, size_t n);` 和 `void * memmove(void * s1, const void * s2, size_t n);` *memcpy()* 要求两个位置之间不重叠， *memmove()* 允许重叠。

### static

`double stick(double ar[static 20]);`

函数原型中的 *static* 表示数组至少具有20个元素。

### 函数原型中的const和restrict

`void ofmouth(int * const a1, int * restrict a2, int n);` 的等价形式是：

`void ofmouth(int a1[const], int a2[restrict], int n);`

## Chapter 12 文件输入/输出

### 文件模式

了解二进制模式和文本模式

### 标准文件指针

stdin, stdout, stderr

### fopen()

`FILE * fopen(const char * PATH, const char * FORMAT);`

打开文件成功则返回文件指针，否则返回NULL

模式字符串：

- `r` 可以读取，文件必须存在
- `w` 可以写入，不存在则创建，存在则将长度截取为零
- `a` 可以追加写入，不存在则创建
- `r+` 可以读取和写入，不会自动创建
- `w+` 可以读取和写入，不存在则创建，存在则将长度截为零
- `a+` 可以读取和追加写入，不存在则创建
- `rb`, `rb+` 使用二进制模式写入文本
- `x` 附加在`w`后面，使得文件存在时出错

### getc() putc()

`getc(fp);`

`putc(ch, fp);`

### fclose()

关闭由文件指针指定的文件，成功则返回0，失败返回EOF。

### fprintf() fscanf()

注意与`putc()`不同的是，*`fprintf()`* 等函数以文件指针作为第一个参数

### fgets() fputs()

`fgets()` 的第一个参数是保存内容char数组名称，第二个参数是字符串的长度（最多会读取(长度-1)个字符），接下来是文件指针。保留换行符，再向末尾追加空字符。

遇到EOF时返回NULL。

`fputs` 的第一个参数时保存内容的char数组名，第二个参数是文件指针。

### funget(int ch, FILE * fp)

把一个字符放回输入流
