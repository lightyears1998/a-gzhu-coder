# 编译原理

## 编译原理概论

### 典型编译器结构

1. 词法分析器（源代码 -> 单词符号）
2. 语法分析器（单词符号 -> 语法单位）
3. 语义分析与中间代码生成（语法单位 -> 四元式）
4. 优化（优化四元式）
5. 目标代码生成（目标代码）

其中出错处理和表格管理贯穿整个流程。编译程序花费时间最多的部分是建表、读表和维护表的性质的过程。

### 常见编译器开发方法

1. 自编译
2. 交叉编译
3. 自展
4. 移植（古典方法）

## 词法分析

*词法分析* / *词法分析器* / *扫描器* 负责将源程序转换为单词符号。

- **单词符号二元式** `(单词种别, 单词本身的值)`
- **状态转换图** 双圆圈表示终态，终态上附上`*`以表示识别完成后将最后读入的符号回退一个。

### 正规表达式

*正规表达式* / *正则表达式* / *Regular Expression*

- **定义** 由基础规则、归纳规则和界限规则来递归定义的表达式
  - **字** 由字母表中字符构成的有序序列；字也包括空字
- **符号** `Σ` 字母表 `ε` 空字 `Φ`空集
- **操作** `・` 连接 `|` 或 `*` 闭包 `+` 正则闭包
- **性质**
  - `R+ == RR*` 正则闭包

### 有限状态自动机 FA, Finite Automation

- 有限状态自动机 FA(S, Σ, f, Q, Z)
    1. S 状态集
    2. Σ 字母表
    3. f 状态集x字母表到状态的映射
    4. Q 初态集合
    5. Z 终态集合
- 确定有限自动机 DFA(S, Σ, f, s0, Z)
    1. f SxΣ的单值映射
    2. 初态唯一
- 非确定有限自动机 NFADFA(S, Σ, f, Q, Z)
    1. f SxΣ*到S的子集的映射（状态可以以字符串为转换条件，后继状态可以不唯一，后继状态可以不存在）
    2. Q 非空初态集合

有限自动机可以使用状态转换图和状态转换矩阵来表示。

#### 通过正规表达式构建NFA

1. 或`|`的转换方法
2. 连接`·`的转换方法
3. 闭包`*`的转换方法（空字、环、空字）

#### NFA的确定化

- ε_CLOSURE(X) 空字闭包，X中每一个状态经过任意次（包括零次）空字ε后可达的状态的集合。
- Iₐ(X) 关于a的字母闭包，X中每一个状态经过一次字符a后可达的状态的空字闭包的并集。

采用子集法。从求初态的空字闭包的字母闭包开始，不断求解新集合的字母闭包，直到没有新的集合出现为止。对已求出的集合进行重命名。

1. 构造一张转换表，第一列为状态子集I，对不同的a(a∈Σ)在表中单独设置一列Iₐ。
2. 表的第一行的第一列为初态的空字闭包
3. 根据第一列的I为每一个a求Iₐ，如果此Iₐ不同于第一列的任何一个已经存在的状态子集I，则将其顺序放入空行中的第一列。
4. 重复以上步骤。
5. 重命名第一列的每一个状态子集。

#### DFA的化简

采用子集法。先将DFA中的状态分为终态和非终态的，得到基本划分。对当前已经得出的划分，求解每一个划分是否可以进一步划分，直到不能划分为止。

1. 将DFA中的终态和非终态分开，得到初始划分。
2. 对当前得出的划分，对每一个子集I，检查每一个a∈Σ，如果Iₐ不包含在当前得到的划分的任何一个子集中（即横跨两个或多个子集），则将I继续划分。
3. 重复上述步骤，直到子集的个数不再增加。

### 词法分析器的自动生成

典型的程序有Antlr和Lex。
